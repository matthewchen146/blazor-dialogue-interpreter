@page "/"
@inject HttpClient Http
@inject IJSRuntime JS
@using Parser

<PageTitle>Dialogue Interpreter</PageTitle>

<main>
    <section class="editor">
        <section class="editor-column left">
            <div class="script-tools">
                <button>Export</button>
                <button @onclick="HandleImportClick">Import</button>
            </div>
            <div class="script-container">
                <textarea class="script" spellcheck="false" value="@script"></textarea>
                <pre class="script-view"></pre>
            </div>
        </section>

        <section class="editor-column right">
            <div class="test">
                <div class="dialogue-container">
                    <div class="dialogue-header">
                        <div class="speaker-label">Speaker</div>
                    </div>
                    <div class="dialogue-box">dialogue box</div>
                    <div class="dialogue-footer">
                        <button class="next-button" @onclick="HandleNextClick">Next</button>
                    </div>
                </div>
                <div class="options-container">

                </div>
                <div class="test-tools">
                    <button @onclick="HandleRunClick">Run</button>
                    <select class="conversation-selector"></select>
                    <button @onclick="Parse">Parse</button>
                </div>
            </div>

            <pre class="log"></pre>
        </section>
    </section>
</main>

@code
{
    private DialogueInterpreter dialogueInterpreter = new();

    private string? script = "";

    [JSInvokable]
    public async void Log(string? message, int level = 0)
    {
        if (message == null)
        {
            return;
        }
        string newLine = $"<span class='log-line level-{level}'>{message}</span>";
        await JS.InvokeVoidAsync("addLogInnerHTML", newLine);
    }

    private async void HandleImportClick()
    {
        await JS.InvokeVoidAsync("callFunction", @"
        const input = document.createElement('input');
        input.type = 'file';
        input.addEventListener('change', () => {
            let files = Array.from(input.files);
            console.log(files);
        })
        input.click();
        ");
    }

    [JSInvokable]
    public async void UpdateScript(string newScript)
    {
        script = newScript;

        int result = dialogueInterpreter.Load(script, out ErrorInfo? error, out DialogueInterpreter.DialogueData dialogueData);

        if (result == 0 && error != null)
        {
            Log($"Dialogue Error - {error}", 2);
        }

        @* return; *@

        string scriptViewText = "";

        int columnIndex = 0;

        Console.WriteLine("populating Fancy Script View");

        List<string> scriptLines = new() {""};

        for (int index = 0; index < dialogueData.tokens.Count; index++)
        {
            Token token = dialogueData.tokens[index];

            string whitespace = "";
            while (token.position.lineIndex >= scriptLines.Count)
            {
                scriptLines.Add("");
                columnIndex = 0;
            }
            while (token.position.columnIndex > columnIndex)
            {
                whitespace += ' ';
                columnIndex += 1;
            }

            columnIndex += ((string)token.value).Length;

            // set up span
            List<string> classes = new() {token.type};

            if (index > 0 && dialogueData.tokens[index - 1].type == "command-prefix")
            {
                classes.Add("command");
            }

            scriptLines[token.position.lineIndex] += $"<span class='{string.Join(' ', classes)}'>{whitespace + token.value}</span>";

        }

        Token lastToken = dialogueData.tokens[dialogueData.tokens.Count - 1];
        Console.WriteLine($"DIFFERENCE IN LENGTH: {lastToken.position.index + lastToken.value.Length}, {script.Length}");

        int lastIndex = lastToken.position.index + lastToken.value.Length;

        // fill remaining text
        while (lastIndex < script.Length)
        {
            if (script[lastIndex] == '\n')
            {
                scriptLines.Add("");
                lastIndex++;
            }
            if (lastIndex == script.Length)
            {
                break;
            }

            scriptLines[scriptLines.Count - 1] += script[lastIndex];

            lastIndex++;
        }

        for (int index = 0; index < scriptLines.Count; index++)
        {
            string newline = index > 0 ? "\n" : "";
            string line = scriptLines[index];

            List<string> classes = new();

            if (result == 0 && error != null && error.position.lineIndex == index)
            {
                classes.Add("error");
            }

            scriptViewText += $"{newline}<span class='script-line {string.Join(' ', classes)}' data-line='{index + 1}'>{line}</span>";
        }

        


        string conversationSelectorInnerHTML = "";
        foreach (string conversationName in dialogueData.conversations.Keys)
        {
            conversationSelectorInnerHTML += $"<option value='{conversationName}'>{conversationName}</option>";
        }
        await CallBySelector(".conversation-selector", $"element.innerHTML = `{conversationSelectorInnerHTML}`");

        await JS.InvokeVoidAsync("setScriptViewInnerHTML", scriptViewText);

    }
    
    private async void HandleRunClick()
    {
        Log("Starting dialogue...");

        string? conversationName = await CallBySelector<string>(".conversation-selector", "return element.value");
        if (conversationName != null)
        {
            Log($"Starting conversation: {conversationName}");

            int result = dialogueInterpreter.StartConversation(conversationName, out string error);
            if (result == 0)
            {
                Log($"Failed to start conversation - {error}");
            }
        }
    }

    private void HandleNextClick()
    {
        int result = dialogueInterpreter.Next();
        Log($"next clicked! result: {result}");
    }

    private void Parse()
    {
        @* Parser.Parser parser = new();
        parser.Parse(script, out string _); *@
    }

    [JSInvokable]
    public void HandleOptionClick(int index)
    {
        int result = dialogueInterpreter.ChooseOption(index, out string error);
        if (result == 0)
        {
            Log($"Option Click - {error}", 2);
        }
    }

    private async ValueTask<T> CallBySelector<T>(string selector, string callback)
    {
        return await JS.InvokeAsync<T>("callBySelector", selector, callback);
    }

    private async ValueTask CallBySelector(string selector, string callback)
    {
        await JS.InvokeVoidAsync("callBySelector", selector, callback);
    }

    protected override async Task OnInitializedAsync()
    {
        string text = await Http.GetStringAsync("examples/Test.txt");

        script = text;

        dialogueInterpreter.events.On("textChanged", async () => {
            string text = (string)dialogueInterpreter.events.Args[0];
            Log("text changed " + text);
            await CallBySelector(".dialogue-box", "element.textContent = `" + text + "`;");
        });

        dialogueInterpreter.events.On("speakerChanged", async () => {
            string speaker = (string)dialogueInterpreter.events.Args[0];
            Log("speaker changed " + speaker);
            await CallBySelector(".speaker-label", "element.textContent = `" + speaker + "`;");
        });

        dialogueInterpreter.events.On("optionAdded", async () => {
            int index = (int)dialogueInterpreter.events.Args[0];
            string text = (string)dialogueInterpreter.events.Args[1];
            string labelName = (string)dialogueInterpreter.events.Args[2];
            await CallBySelector(".options-container", $@"
            const button = document.createElement('button'); 
            button.textContent = `{text}`;
            button.classList.toggle('option-button', true);
            button.addEventListener('click', () => {{
                window.callDotNetReferenceMethod('index', 'HandleOptionClick', {index});
            }})
            element.appendChild(button);"
            );
        });

        dialogueInterpreter.events.On("optionsCleared", async () => {
            await CallBySelector(".options-container", "while (element.firstChild) {element.removeChild(element.lastChild);}");
        });

        await JS.InvokeVoidAsync("setDotNetReference", "index", DotNetObjectReference.Create(this));

        await JS.InvokeVoidAsync(
            "evalJavaScript", 
            @"
            (() => {

                const callBySelectorMap = new Map();

                window.callBySelector = (selector, callbackString) => {
                    let element = callBySelectorMap.get(selector);
                    if (!element) {
                        element = document.querySelector(selector);
                        if (element) {
                            callBySelectorMap.set(selector, element);
                        } else {
                            console.log('couldnt find element by selector', selector);
                            return;
                        }
                    }
                    const callback = new Function('element', callbackString);
                    if (typeof(callback) == 'function') {
                        return callback(element);
                    }
                };

                const textArea = document.querySelector('.script'); 
                if (!textArea) {
                    console.error('could not find script editor');
                }

                const scriptView = document.querySelector('.script-view');
                
                window.setScriptViewInnerHTML = (text) => {
                    if (scriptView) {
                        scriptView.innerHTML = text;
                    }
                }

                const log = document.querySelector('.log');

                window.addLogInnerHTML = (text) => {
                    if (log) {
                        log.innerHTML += (log.innerHTML.length === 0 ? '' : '\n') + text;
                    }
                }

                const scriptContainer = document.querySelector('.script-container');
                
                function resizeView(setViewContent = true) {
                    const scrollTop = scriptContainer.scrollTop;

                    textArea.style.height = '';
                    textArea.style.height = `${textArea.scrollHeight}px`;

                    if (scriptView) {
                        const rect = textArea.getBoundingClientRect();
                        //scriptView.style.left = rect.x;
                        //scriptView.style.top = rect.y;
                        scriptView.style.width = `${rect.width}px`;
                        scriptView.style.height = `${rect.height}px`;

                        if (setViewContent) {
                            scriptView.textContent = textArea.value;
                        }
                    }

                    scriptContainer.scrollTop = scrollTop;
                }

                function updateScript() {
                    console.debug('calling update script');
                    window.callDotNetReferenceMethod('index', 'UpdateScript', textArea.value);
                }
                
                let scriptCheckTimeout = setTimeout(updateScript, 500);

                setTimeout(() => {
                    resizeView();
                    updateScript();
                }, 1);

                window.addEventListener('resize', resizeView.bind(this, false));

                textArea.addEventListener('input', () => {
                    clearTimeout(scriptCheckTimeout);
                    scriptCheckTimeout = setTimeout(updateScript, 200);

                    resizeView();
                });
            })()
            "
        );
    }

}